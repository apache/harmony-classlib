/*
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

#include "hyport.h"
#include <unistd.h>
#include <string.h>
#include <sys/ucontext.h>
#include "hysignal_context.h"


void
fillInLinux386SignalInfo (struct HyPortLibrary *portLibrary, void *contextInfo,
                          struct HyLinux386SignalInfo *hyinfo)
{
  struct sigcontext *sigContext;
  ucontext_t *uContext;

#ifdef HYIA64
  assert(0); // should never be here
#endif

  uContext = (ucontext_t *) contextInfo;
  sigContext = (struct sigcontext *) &uContext->uc_mcontext;

  hyinfo->sigContext = sigContext;
  /* module info is filled on demand */
}


U_32
infoForSignal (struct HyPortLibrary *portLibrary,
               struct HyLinux386SignalInfo *info, I_32 index,
               const char **name, void **value)
{
  *name = "";

  switch (index)
    {

    case HYPORT_SIG_SIGNAL_TYPE:
    case 0:
      *name = "HyGeneric_Signal_Number";
      *value = &info->portLibrarySignalType;
      return HYPORT_SIG_VALUE_32;

    case HYPORT_SIG_SIGNAL_PLATFORM_SIGNAL_TYPE:
    case 1:
      *name = "Signal_Number";
      *value = &info->sigInfo->si_signo;
      return HYPORT_SIG_VALUE_32;

    case HYPORT_SIG_SIGNAL_ERROR_VALUE:
    case 2:
      *name = "Error_Value";
      *value = &info->sigInfo->si_errno;
      return HYPORT_SIG_VALUE_32;

    case HYPORT_SIG_SIGNAL_CODE:
    case 3:
      *name = "Signal_Code";
      *value = &info->sigInfo->si_code;
      return HYPORT_SIG_VALUE_32;

    case HYPORT_SIG_SIGNAL_HANDLER:
    case 4:
      *name = "Handler1";
      *value = &info->handlerAddress;
      return HYPORT_SIG_VALUE_ADDRESS;

    case 5:
      *name = "Handler2";
      *value = &info->handlerAddress2;
      return HYPORT_SIG_VALUE_ADDRESS;

    case HYPORT_SIG_SIGNAL_INACCESSIBLE_ADDRESS:
    case 6:
      /* si_code > 0 indicates that the signal was generated by the kernel */
      if (info->sigInfo->si_code > 0)
        {
          if ((info->sigInfo->si_signo == SIGBUS)
              || (info->sigInfo->si_signo == SIGSEGV))
            {
              *name = "InaccessibleAddress";
              *value = &info->sigInfo->si_addr;
              return HYPORT_SIG_VALUE_ADDRESS;
            }
        }
      return HYPORT_SIG_VALUE_UNDEFINED;

    default:
      return HYPORT_SIG_VALUE_UNDEFINED;
    }
}


U_32
infoForFPR (struct HyPortLibrary *portLibrary,
            struct HyLinux386SignalInfo *info, I_32 index, const char **name,
            void **value)
{
  static const char *n_xmm[] = {
    "xmm0",
    "xmm1",
    "xmm2",
    "xmm3",
    "xmm4",
    "xmm5",
    "xmm6",
    "xmm7"
  };

#ifdef HYIA64
  assert(0); // should never be here
#endif

  switch (index)
    {
    default:
      return HYPORT_SIG_VALUE_UNDEFINED;
    }
}


U_32
infoForGPR (struct HyPortLibrary *portLibrary,
            struct HyLinux386SignalInfo *info, I_32 index, const char **name,
            void **value)
{
  *name = "";

#ifdef HYIA64
  assert(0); // should never be here
#endif

  switch (index)
    {
    case HYPORT_SIG_GPR_X86_EDI:
	case HYPORT_SIG_GPR_AMD64_RDI:
    case 0:
#ifdef HYX86_64
      *name = "RDI";
      *value = &info->sigContext->rdi;
#endif
#ifdef HYX86
      *name = "EDI";
      *value = &info->sigContext->edi;
#endif
	  return HYPORT_SIG_VALUE_ADDRESS;
    case HYPORT_SIG_GPR_X86_ESI:
	case HYPORT_SIG_GPR_AMD64_RSI:
    case 1:
#ifdef HYX86
      *name = "ESI";
      *value = &info->sigContext->esi;
#endif
#ifdef HYX86_64
      *name = "RSI";
      *value = &info->sigContext->rsi;
#endif
      return HYPORT_SIG_VALUE_ADDRESS;
    case HYPORT_SIG_GPR_X86_EAX:
    case HYPORT_SIG_GPR_AMD64_RAX:
    case 2:
#ifdef HYX86
      *name = "EAX";
      *value = &info->sigContext->eax;
#endif
#ifdef HYX86_64
      *name = "RAX";
      *value = &info->sigContext->rax;
#endif
	  return HYPORT_SIG_VALUE_ADDRESS;
    case HYPORT_SIG_GPR_X86_EBX:
    case HYPORT_SIG_GPR_AMD64_RBX:
    case 3:
#ifdef HYX86
      *name = "EBX";
      *value = &info->sigContext->ebx;
#endif
#ifdef HYX86_64
      *name = "RBX";
      *value = &info->sigContext->rbx;
#endif
	  return HYPORT_SIG_VALUE_ADDRESS;
    case HYPORT_SIG_GPR_X86_ECX:
    case HYPORT_SIG_GPR_AMD64_RCX:
    case 4:
#ifdef HYX86
      *name = "ECX";
      *value = &info->sigContext->ecx;
#endif
#ifdef HYX86_64
      *name = "RCX";
      *value = &info->sigContext->rcx;
#endif
	  return HYPORT_SIG_VALUE_ADDRESS;
    case HYPORT_SIG_GPR_X86_EDX:
    case HYPORT_SIG_GPR_AMD64_RDX:
    case 5:
#ifdef HYX86
      *name = "EDX";
      *value = &info->sigContext->edx;
#endif
#ifdef HYX86_64
      *name = "RDX";
      *value = &info->sigContext->rdx;
#endif
	  return HYPORT_SIG_VALUE_ADDRESS;
    default:
      return HYPORT_SIG_VALUE_UNDEFINED;
    }

}


U_32
infoForControl (struct HyPortLibrary *portLibrary,
                struct HyLinux386SignalInfo *info, I_32 index,
                const char **name, void **value)
{
  *name = "";
  U_8 *eip;

#ifdef HYIA64
  assert(0); // should never be here
#endif

  switch (index)
    {
    case HYPORT_SIG_CONTROL_PC:
    case 0:
#ifdef HYX86
      *name = "EIP";
      *value = (void *) &(info->sigContext->eip);
#endif
#ifdef HYX86_64
      *name = "RIP";
      *value = (void *) &(info->sigContext->rip);
#endif
	  return HYPORT_SIG_VALUE_ADDRESS;
#ifdef HYX86
    case 1:
      *name = "ES";
      *value = (void *) &(info->sigContext->es);
      return HYPORT_SIG_VALUE_ADDRESS;
    case 2:
      *name = "DS";
      *value = (void *) &(info->sigContext->ds);
      return HYPORT_SIG_VALUE_ADDRESS;
#endif
    case HYPORT_SIG_CONTROL_SP:
    case 3:
#ifdef HYX86
      *name = "ESP";
      *value = (void *) &(info->sigContext->esp);
#endif
#ifdef HYX86_64
      *name = "RSP";
      *value = (void *) &(info->sigContext->rsp);
#endif
      return HYPORT_SIG_VALUE_ADDRESS;
    case 4:
#ifndef HYIA64
      *name = "EFlags";
      *value = (void *) &(info->sigContext->eflags);
      return HYPORT_SIG_VALUE_ADDRESS;
    case 5:
      *name = "CS";
      *value = (void *) &(info->sigContext->cs);
#endif
      return HYPORT_SIG_VALUE_ADDRESS;
#ifdef HYX86
    case 6:
      *name = "SS";
      *value = (void *) &(info->sigContext->ss);
      return HYPORT_SIG_VALUE_ADDRESS;
#endif
	case HYPORT_SIG_CONTROL_BP:
    case 7:
#ifdef HYX86
      *name = "EBP";
      *value = &info->sigContext->ebp;
#endif
#ifdef HYX86_64
      *name = "RBP";
      *value = &info->sigContext->rbp;
#endif
	  return HYPORT_SIG_VALUE_ADDRESS;
    default:
      return HYPORT_SIG_VALUE_UNDEFINED;
    }
}


U_32
infoForModule (struct HyPortLibrary *portLibrary,
               struct HyLinux386SignalInfo *info, I_32 index,
               const char **name, void **value)
{
  void *address;
  Dl_info *dl_info = &(info->dl_info);
  *name = "";

#ifdef HYIA64
  assert(0); // should never be here
#endif

#ifdef HYX86
  address = (void *) info->sigContext->eip;
  int dl_result = dladdr ((void *) info->sigContext->eip, dl_info);
#endif
#ifdef HYX86_64
  address = (void *) info->sigContext->rip;
  int dl_result = dladdr ((void *) info->sigContext->rip, dl_info);
#endif
#ifdef HYIA64
  int dl_result = 0;
#endif
  switch (index)
    {
    case HYPORT_SIG_MODULE_NAME:
    case 0:
      *name = "Module";
      if (dl_result)
        {
          *value = (void *) (dl_info->dli_fname);
          return HYPORT_SIG_VALUE_STRING;
        }
      return HYPORT_SIG_VALUE_UNDEFINED;
    case 1:
      *name = "Module_base_address";
      if (dl_result)
        {
          *value = (void *) &(dl_info->dli_fbase);
          return HYPORT_SIG_VALUE_ADDRESS;
        }
      return HYPORT_SIG_VALUE_UNDEFINED;
    case 2:
      *name = "Symbol";
      if (dl_result)
        {
          if (dl_info->dli_sname != NULL)
            {
              *value = (void *) (dl_info->dli_sname);
              return HYPORT_SIG_VALUE_STRING;
            }
        }
      return HYPORT_SIG_VALUE_UNDEFINED;
    case 3:
      *name = "Symbol_address";
      if (dl_result)
        {
          *value = (void *) &(dl_info->dli_saddr);
          return HYPORT_SIG_VALUE_ADDRESS;
        }
      return HYPORT_SIG_VALUE_UNDEFINED;
    default:
      return HYPORT_SIG_VALUE_UNDEFINED;
    }
}
