/*
 *  Copyright 2005 The Apache Software Foundation or its licensors, as applicable.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

/**
* @author Alexander Y. Kleymenov
* @version $Revision$
*/

package org.apache.harmony.security.provider.cert;


import java.io.IOException;
import java.io.InputStream;
import java.security.cert.CRL;
import java.security.cert.CRLException;
import java.security.cert.CertPath;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactorySpi;
import java.security.cert.X509CRL;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;

import org.apache.harmony.luni.util.Base64;
import org.apache.harmony.security.asn1.BerInputStream;

/**
 * X509 Certificate Factory Service Provider Interface Implementation.
 * It supports CRLs and Certificates in (PEM) ASN.1 DER encoded form,
 * and Certification Paths in PkiPath and PKCS7 formats.
 * For Certificates and CRLs factory maintains the caching
 * mechanisms allowing to speed up repeated Certificate/CRL
 * generation.
 * @see Cache
 */
public class X509CertFactoryImpl extends CertificateFactorySpi {

    // certificate cache
    private static Cache CERT_CASHE = new Cache();
    // crl cache, 24 leading/trailing bytes will be used for hash computation
    private static Cache CRL_CASHE = new Cache(24);

    /**
     * Default constructor.
     * Creates the instance of Certificate Factory SPI ready for use.
     */
    public X509CertFactoryImpl() { }

    /**
     * Generates the X.509 certificate from the data in the stream.
     * The data in the stream can be either in ASN.1 DER encoded X.509
     * certificate, or PEM (Base64 encoding bounded by
     * <code>"-----BEGIN CERTIFICATE-----"</code> at the beginning and
     * <code>"-----END CERTIFICATE-----"</code> at the end) representation
     * of the former encoded form.
     *
     * Before the generation the attempt the encoded form is looked up in
     * the cache. If the cache contains the certificate with requested encoded
     * form it is returned from it, otherwise it is generated by ASN.1
     * decoder.
     *
     * @see java.security.cert.CertificateFactorySpi#engineGenerateCertificate(InputStream)
     * method documentation for more info
     */
    public Certificate engineGenerateCertificate(InputStream inStream)
            throws CertificateException {
        try {
            if (!inStream.markSupported()) {
                // create the mark supporting wrapper
                inStream = new RestoringInputStream(inStream);
            }
            // mark is needed to recognize the format of the provided encoding
            // (ASN.1 or PEM)
            inStream.mark(32);
            byte[] buff = new byte[28];
            // read the prefix of the encoding
            if (inStream.read(buff) < 28) {
                throw new CertificateException(
                        "Input Stream contains not enought data.");
            }
            // check whether the provided certificate is in PEM encoded form
            if ("-----BEGIN CERTIFICATE-----".equals(new String(buff, 0, 27))) {
                // read PEM encoded form
                int size = inStream.available();
                if (size == 0) {
                    size = 2048;
                }
                buff = new byte[size];
                int index=0, ch;
                // read the Base64 encoded certificate into the buffer
                // expect "-----END CERTIFICATE-----" at the end
                while ((ch = inStream.read()) != '-') {
                    if (ch == -1) {
                        throw new CertificateException(
                                "Incorrect Base64 encoding: unexpected EOF.");
                    }
                    buff[index++] = (byte) ch;
                    // enlarge the buffer if needed
                    if (index == size) {
                        byte[] newbuff = new byte[size+1024];
                        System.arraycopy(buff, 0, newbuff, 0, size);
                        buff = newbuff;
                    }
                }
                byte[] tmp = new byte[25];
                inStream.read(tmp);
                // check the trailing sequence
                if (!new String(tmp).startsWith("----END CERTIFICATE-----")) {
                    throw new CertificateException(
                    "Incorrect Base64 encoding: 'END CERTIFICATE' expected.");
                }
                // skip new line: set the position to the next certificate:
                inStream.mark(1);
                while (((ch = inStream.read()) != -1) 
                        && (ch == '\n' || ch == '\r')) {
                    inStream.mark(1);
                }
                inStream.reset();
                // retrieve the ASN.1 DER encoded form
                buff = Base64.decode(buff, index);
                if (buff == null) {
                    throw new CertificateException(
                            "Incorrect Base64 encoding.");
                }
                // check whether certificate has already been generated and
                // stored in the cache
                long hash = CERT_CASHE.getHash(buff);
                if (CERT_CASHE.contains(hash)) {
                    // preliminary check is successful, do more accurate check
                    Certificate res = (Certificate) CERT_CASHE.get(hash, buff);
                    if (res != null) {
                        // found in the cache
                        return res;
                    }
                }
                // there is no generated certificate in the cache,
                // so generate it
                Certificate res = new X509CertImpl(buff);
                // put newly generated certificate in the cache
                CERT_CASHE.put(hash, buff, res);
                return res;
            } else {
                // read ASN.1 DER encoded form
                inStream.reset();
                // check whether certificate has already been generated and
                // stored in the cache
                long hash = CERT_CASHE.getHash(buff);
                if (CERT_CASHE.contains(hash)) {
                    // preliminary check is successful, do more accurate check.
                    byte[] encoding = new byte[BerInputStream.getLength(buff)];
                    // read full encoding form from the stream
                    inStream.read(encoding);
                    // try to retrieve from the cache
                    Certificate res =
                        (Certificate) CERT_CASHE.get(hash, encoding);
                    if (res != null) {
                        // found in the cache
                        return res;
                    }
                    // there is no generated certificate in the cache,
                    // so generate it
                    res = new X509CertImpl(encoding);
                    // put newly generated certificate in the cache
                    CERT_CASHE.put(hash, encoding, res);
                    return res;
                } else {
                    // there is no generated certificate in the cache,
                    // so generate it
                    Certificate res = new X509CertImpl(inStream);
                    // put newly generated certificate in the cache
                    CERT_CASHE.put(hash, res.getEncoded(), res);
                    return res;
                }
            }
        } catch (IOException e) {
            throw new CertificateException(e);
        }
    }

    /**
     * Generates the collection of the certificates on the base of provided
     * via input stream encodings.
     * @see java.security.cert.CertificateFactorySpi#engineGenerateCertificates(InputStream)
     * method documentation for more info
     */
    public Collection<? extends Certificate>
            engineGenerateCertificates(InputStream inStream)
                throws CertificateException {
        ArrayList result = new ArrayList();
        try {
            if (!inStream.markSupported()) {
                // create the mark supporting wrapper
                inStream = new RestoringInputStream(inStream);
            }
            inStream.mark(1);
            // until the end of the stream is not reached ..
            while (inStream.read() != -1) {
                inStream.reset();
                // .. generate the certificate and add it to the resulting list
                result.add(engineGenerateCertificate(inStream));
                inStream.mark(1);
            }
        } catch (IOException e) {
            throw new CertificateException(e);
        }
        return result;
    }

    /**
     * @see java.security.cert.CertificateFactorySpi#engineGenerateCRL(InputStream)
     * method documentation for more info
     */
    public CRL engineGenerateCRL(InputStream inStream)
            throws CRLException {
        try {
            if (!inStream.markSupported()) {
                // create the mark supporting wrapper
                inStream = new RestoringInputStream(inStream);
            }
            // mark is needed to recognize the format of the provided encoding
            // (ASN.1 or PEM)
            inStream.mark(32);
            byte[] buff = new byte[25]; // take one byte for new line
            // read the prefix of the encoding
            if (inStream.read(buff) < 25) {
                throw new CRLException(
                        "Input Stream contains not enought data.");
            }
            // check whether the provided crl is in PEM encoded form
            if ("-----BEGIN X509 CRL-----".equals(new String(buff, 0, 24))) {
                // read PEM encoded form
                int size = inStream.available();
                if (size == 0) {
                    size = 1024;
                }
                buff = new byte[size];
                int index=0, ch;
                // read the Base64 encoded crl into the buffer
                while ((ch = inStream.read()) != '-') {
                    if (ch == -1) {
                        throw new CRLException(
                                "Incorrect Base64 encoding: unexpected EOF.");
                    }
                    buff[index++] = (byte) ch;
                    // enlarge the buffer if needed
                    if (index == size) {
                        byte[] newbuff = new byte[size+1024];
                        System.arraycopy(buff, 0, newbuff, 0, size);
                        buff = newbuff;
                    }
                }
                byte[] tmp = new byte[21];
                inStream.read(tmp);
                if (!new String(tmp).startsWith("----END X509 CRL-----")) {
                    throw new CRLException(
                    "Incorrect Base64 encoding: 'END X509 CRL' expected.");
                }
                // skip new line: set the position to the next certificate:
                inStream.mark(1);
                while (((ch = inStream.read()) != -1) && (ch == '\n' || ch == '\r')) {
                    inStream.mark(1);
                }
                inStream.reset();
                buff = Base64.decode(buff, index);
                if (buff == null) {
                    throw new CRLException("Incorrect Base64 encoding.");
                }
                long hash = CRL_CASHE.getHash(buff);
                if (CRL_CASHE.contains(hash)) {
                    X509CRL res = (X509CRL) CRL_CASHE.get(hash, buff);
                    if (res != null) {
                        return res;
                    }
                }
                X509CRL res = new X509CRLImpl(buff);
                CRL_CASHE.put(hash, buff, res);
                return res;
            } else {
                inStream.reset();
                long hash = CRL_CASHE.getHash(buff);
                if (CRL_CASHE.contains(hash)) {
                    byte[] encoding = new byte[BerInputStream.getLength(buff)];
                    inStream.read(encoding);
                    CRL res =
                        (CRL) CRL_CASHE.get(hash, encoding);
                    if (res != null) {
                        return res;
                    }
                    res = new X509CRLImpl(encoding);
                    CRL_CASHE.put(hash, encoding, res);
                    return res;
                } else {
                    X509CRL res = new X509CRLImpl(inStream);
                    CRL_CASHE.put(hash, res.getEncoded(), res);
                    return res;
                }
            }
        } catch (IOException e) {
            throw new CRLException(e);
        }
    }

    /**
     * @see java.security.cert.CertificateFactorySpi#engineGenerateCRLs(InputStream)
     * method documentation for more info
     */
    public Collection<? extends CRL> engineGenerateCRLs(InputStream inStream)
            throws CRLException {
        if (inStream == null) {
            throw new CRLException("Null input stream provided.");
        }
        ArrayList result = new ArrayList();
        try {
            if (!inStream.markSupported()) {
                inStream = new RestoringInputStream(inStream);
            }
            inStream.mark(1);
            // FIXME: Check if it is a PKCS7 structure, if not, do following:
            while (inStream.read() != -1) {
                inStream.reset();
                result.add(engineGenerateCRL(inStream));
                inStream.mark(1);
            }
        } catch (IOException e) {
            e.printStackTrace();
            throw new CRLException(e);
        }
        return result;
    }

    /**
     * @see java.security.cert.CertificateFactorySpi#engineGenerateCertPath(InputStream)
     * method documentation for more info
     */
    public CertPath engineGenerateCertPath(InputStream inStream)
            throws CertificateException {
        return X509CertPathImpl.getInstance(inStream);
    }

    /**
     * @see java.security.cert.CertificateFactorySpi#engineGenerateCertPath(InputStream,String)
     * method documentation for more info
     */
    public CertPath engineGenerateCertPath(
            InputStream inStream, String encoding) throws CertificateException {
        return X509CertPathImpl.getInstance(inStream, encoding);
    }

    /**
     * @see java.security.cert.CertificateFactorySpi#engineGenerateCertPath(List)
     * method documentation for more info
     */
    public CertPath engineGenerateCertPath(List certificates)
            throws CertificateException {
        return new X509CertPathImpl(certificates);
    }

    /**
     * @see java.security.cert.CertificateFactorySpi#engineGetCertPathEncodings()
     * method documentation for more info
     */
    public Iterator<String> engineGetCertPathEncodings() {
        return X509CertPathImpl.encodings.iterator();
    }

    /*
     * This class extends any existing input stream with
     * mark functionality. It acts as a wrapper over the
     * stream and supports reset to the
     * marked state with readlimit no more than BUFF_SIZE.
     */
    private static class RestoringInputStream extends InputStream {

        // wrapped input stream
        private final InputStream inStream;
        // specifies how much of the read data is buffered
        // after the mark has been set up
        private static final int BUFF_SIZE = 32;
        // buffer to keep the bytes read after the mark has been set up
        private final int[] buff = new int[BUFF_SIZE*2];
        // position of the next byte to read,
        // the value of -1 indicates that the buffer is not used
        // (mark was not set up or was invalidated, or reset to the marked
        // position has been done and all the buffered data was read out)
        private int pos = -1;
        // position of the last buffered byte
        private int bar = 0;
        // position in the buffer where the mark becomes invalidated
        private int end = 0;

        /**
         * Creates the mark supporting wrapper over the stream.
         */
        public RestoringInputStream(InputStream inStream) {
            this.inStream = inStream;
        }

        /**
         * @see java.io.InputStream#available()
         * method documentation for more info
         */
        public int available() throws IOException {
            return (bar - pos) + inStream.available();
        }

        /**
         * @see java.io.InputStream#close()
         * method documentation for more info
         */
        public void close() throws IOException {
            inStream.close();
        }

        /**
         * @see java.io.InputStream#mark(int readlimit)
         * method documentation for more info
         */
        public void mark(int readlimit) {
            if (pos < 0) {
                pos = 0;
                bar = 0;
                end = BUFF_SIZE - 1;
            } else {
                end = (pos + BUFF_SIZE - 1) % BUFF_SIZE;
            }
        }

        /**
         * @see java.io.InputStream#markSupported()
         * method documentation for more info
         */
        public boolean markSupported() {
            return true;
        }

        /**
         * Reads the byte from the stream. If mark has been set up
         * and was not invalidated byte is read from the underlying
         * stream and saved into the buffer. If the current read position
         * has been reset to the marked position and there are remaining
         * bytes in the buffer, the byte is taken from it. In the other cases
         * (if mark has been invalidated, or there are no buffered bytes)
         * the byte is taken directly from the underlying stream and it is
         * returned without saving to the buffer.
         *
         * @see java.io.InputStream#read()
         * method documentation for more info
         */
        public int read() throws IOException {
            // if buffer is currently used
            if (pos >= 0) {
                // current position in the buffer
                int cur = pos % BUFF_SIZE;
                // check whether the buffer contains the data to be read
                if (cur < bar) {
                    // return the data from the buffer
                    pos++;
                    return buff[cur];
                }
                // check whether buffer has free space
                if (cur != end) {
                    // it has, so read the data from the wrapped stream
                    // and place it in the buffer
                    buff[cur] = inStream.read();
                    bar = cur+1;
                    pos++;
                    return buff[cur];
                } else {
                    // buffer if full and can not operate
                    // any more, so invalidate the mark position
                    // and turn off the using of buffer
                    pos = -1;
                }
            }
            // buffer is not used, so return the data from the wrapped stream
            return inStream.read();
        }

        /**
         * @see java.io.InputStream#read(byte[] b)
         * method documentation for more info
         */
        public int read(byte[] b) throws IOException {
            return read(b, 0, b.length);
        }

        /**
         * @see java.io.InputStream#read(byte[] b, int off, int len)
         * method documentation for more info
         */
        public int read(byte[] b, int off, int len) throws IOException {
            int read_b;
            int i;
            for (i=0; i<len; i++) {
                if ((read_b = read()) == -1) {
                    return (i == 0) ? -1 : i;
                }
                b[off+i] = (byte) read_b;
            }
            return i;
        }

        /**
         * @see java.io.InputStream#reset()
         * method documentation for more info
         */
        public void reset() throws IOException {
            if (pos >= 0) {
                pos = (end + 1) % BUFF_SIZE;
            } else {
                throw new IOException("Could not reset the stream: "
                    + "position became invalid or stream has not been marked.");
            }
        }

        /**
         * @see java.io.InputStream#skip(long n)
         * method documentation for more info
         */
        public long skip(long n) throws IOException {
            if (pos >= 0) {
                long i = 0;
                int av = available();
                if (av < n) {
                    n = av;
                }
                while ((i < n) && (read() != -1)) {
                    i++;
                }
                return i;
            } else {
                return inStream.skip(n);
            }
        }
    }
}

